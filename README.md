Цель работы: Написание алгоритмов кодирования информации по алгоритмам Шеннона-Фано и Хаффмана.

Работа состоит из пяти отдельных модулей, каждый из которых написан на языке высого уровня Python 3.9.

Краткое описание программы: Дан какой-нибудь текст с символами национального алфавита, геде присутствуют хотя бы два различных символа.
По окончании программы в консоль будет напечатаны две таблицы. В первой таблице будет содержаться информация о количестве встречаемости конкретного
символа в тексте, двоичный код по алгоритму Шеннона-Фано, двоичный код по алгоритму Хаффмана. Во второй табличе будет подсчитано общее количество
символов в тексте, а также суммарное число бит которое понадобится для кодирования текста кодами алгоритма Шеннона-Фано и суммарное число бит для
кодирования алгоритмом Хаффмана. Также будет посчитана средняя Энтропия источника (Не помню точного определения).



fano_algorithm.py --> Модуль в котором определена основная функция fano_algorithm(input_array), реализованная на основе алгоритма кодирования информации
                      по алгоритму Шеннона-Фано. Данная функция возвращает структуру дерево -- массив кортежей.
                      input_array -- это массив количаства вхождений различных символов в исследуемом тексте, отсортированный по убыванию.
                      
                      (Данный алгоритм является рекурсивным, так как строит дерево с корневого узла). Детали алгоритма, считаю, здесть неуместны.


haffman_algorithm.py -->  Модуль в котором определена основня функция haffman_algorithm(input_array), которая реализована по алгоритму кодирования Хаффмана.
                          Функция возвращает абсолютно тоже самое, что и функция fano_algorithm(...)... (Имеется ввиду, что возвращается также массив
                          кортежей), но конечно не идентичных с функцией fano_algorithm(...).
                          input_array точно такой же как и в первой функции.
                          
                          (Данный алгоритм не рекурсивный и спойкойно реализуется с помощью чикла while и двух переменных). Детали алгоритма опускаются.


binary_tree_traversal.py -->  Модуль в котором реализована функция binary_tree_traversal(input_array, root_nood_indxe=0). Задача данной функции -- это
                              осуществить обход деревьев (от корневого узла к потомкам), составленных функциями fano_algorithm(...) и haffman_algorithm(...).
                              Обход деревьев реализован рекурсивным образом. На выходе получаем массив двоичных кодов, для кодирования символов.
                              
                              (Рекурсивный алгоритм.). input_array -- структура дерева, созданного алгоритмом Шеннона или Хаффмана (список кортежей),
                              root_nood_indxe -- индекс корневого узла, по умолчанию он находится на нулевой позиции -- поэтому по умолчанию стоит 0.


create_input_array.py --> Модуль в котором осуществляется подготовка данных для дальнейшей работы функция Хаффмана, Фано, а также для печати итоговой
                          таблицы. Функция create_input_array(directory), принимае на вход директорию, где расположен текстовый файл, для которого
                          требуется составить кодовые таблицы. Данная функция возвращает словарь, где ключами являются символы, а значениями являются
                          количество данных символов в исходном тексте.
                          directory -- путь к текстовому файлу (в формате .txt)


main.py -->   Основной файл, который требуется запустить, чтобы в терминал были напечатаны кодовая таблица и таблица с подведением итогов -- (какой
              алгоритм является более эффективным для кодирования информации данног текста). Также там определена функция main(), которая и выполняет
              вышеперечисленные действия.
